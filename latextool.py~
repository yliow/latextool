
"""
The input is a string.
Example:
  graph(shape='circle',
        minimumsize='14mm',
        layout='''
          A
         B C
        D E F G
        ''',
        edges='A-B,A>C',
        A='shape=rectangle, label=$A$, pos=(3,5)',
        B='label=B',
        )
The last keyword args A,B are kept in the dict args.
"""

import re

    
def graph_coloring_label(
    *args
    ):
    """ args is a list of (var,value,list) """

    args = args[0]
    #print
    #print "args:", args
    #print
    return args
    
    #domains = []
    domains = [(len(z),z) for x,y,z in args]
    domains.sort()
    longest_domain = domains[-1][1]

    # put mbox into arg which has [] list
    def f(z):
        if z == []: xs = longest_domain
        else: xs = z
        return r'\mbox{$\{%s\}$}' % (','.join(xs))
    
    args = [(x,y,f(z)) for x,y,z in args]
    
    lines = [r"$%s$ & \hskip-9pt $= %s$ & \mbox{$%s$}" % (x,y,z) \
             for x,y,z in args]

    return r'''\begin{tabular}{lll}
\end{tabular}'''




def automata(
    xscale=1,
    yscale=1,
    layout="",
    separator="|",
    edges="",
    **args
    ):
    """
automata(layout='''
A B C D
''',
edges='A,$a$,A|A,$a,b$,B|A,$a,\epsilon$,C'
A='initial|accept|label=$q_0$',
B='accept|label=$q_1$',
"""
    pos = positions(layout,xscale,yscale)
    node = {}
    #print "pos:", pos
    for k,v in pos.items():
        node[k] = {'pos':v}
        node[k]['initial'] = ""
        node[k]['accept'] = ""
        node[k]['label'] = k

    e = {}
    for v in [_ for _ in edges.split(separator) if _ != '']:
        #print "v:", v
        q1,v = v.split(',',1)
        v,q2 = v.rsplit(',',1)
        e[(q1,q2)] = v

    for k in node.keys():
        for v in [_ for _ in args.get(k,'').split(separator) if _ != '']:
            if v == 'initial':
                node[k]['initial'] = ",initial"
            elif v == 'accept':
                node[k]['accept'] = ",accepting"
            elif v.startswith('label='):
                node[k]['label'] = v.replace('label=', '').strip()
            else:
                raise ValueError("unknown option for node [%s]" % v)

    # form node string
    node_str = ""
    #print "node:", node
    for k,v in node.items():
        d = {}
        d['name'] = k
        d['label'] = v['label']
        d['initial'] = v['initial']
        d['accept']= v['accept']
        d['pos'] = "(%3s,%3s)" % v['pos']
        node_str += r"\node[state%(initial)s%(accept)s] (%(name)s) at %(pos)s {%(label)s};" % d
        node_str += '\n'

    # form edge string
    # q1==q2: loop above (default)
    #
    # if q1 same row as q2:
    #     if no node between q1 and q2:
    #         if only q1 to q2 but no q2 to q1
    #             straight line
    #         else:
    #             bend left=15
    #     else:
    #         bend left=angle where angle = 30 + 15* num nodes between   
    # else if q1 same column as q2
    #     not possible
    # else
    #     straight line
    #
    # p0,p1 when is p in between p0,p1?
    # u=p0,p same dir as v=p,p1
    def edge_shape(q0,q1,node,e):
        def between(p0,p,p1):
            #print "p0,p,p1:",p0,p,p1
            u = p[0]-p0[0], p[1]-p0[1]
            v = p1[0]-p[0], p1[1]-p[1]
            #print "u,v:",u,v
            # u[0]=c*v[0], u[1]=c*v[1]
            if u[0] == 0 and v[0] == 0:
                return u[1] * v[1] > 0
            elif u[1] == 0 and v[1] == 0:
                return u[0] * v[0] > 0
            return u[0]*v[1] == u[1]*v[0]
        if q0==q1:
            return "[loop above]" # have to decide on which loop
        p0,p1 = node[q0]['pos'],node[q1]['pos']
        # count num of nodes between
        count = 0
        #print "check between for",q0,q1
        for p in node.keys():
            if p not in [q0,q1]:
                if between(p0,node[p]['pos'],p1):
                    #print "between found:",p
                    count += 1
        #print "q0,q1,count:", q0,q1,count
        if count == 0:
            if (q1,q0) in e.keys(): angle = 10
            else: angle = 0
        else: angle = 30 + 10*count
        
        return "[bend left=%s]" % angle
            
    edge_str = ""
    #print "e:", e
    e2 = e.items()
    e2.sort()
    for k, v in e2:
        q1,q2 = k
        if q1 not in node.keys():
            raise ValueError("state [%s] in edges param not found in layout" % q1)
        if q2 not in node.keys():
            raise ValueError("state [%s] in edges param not found in layout" % q2)

        d = {'q1':q1, 'q2':q2, 'label':v, 'edge':edge_shape(q1,q2,node,e)}
        if q1==q2:
            edge_str += r"(%(q1)s) edge %(edge)s node {%(label)s} ()" % d
        else:
            edge_str += r"(%(q1)s) edge %(edge)s node {%(label)s} (%(q2)s)" % d
        edge_str += '\n'
    return r'''
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,auto,initial text=]
%s

\path[->]
%s
;
\end{tikzpicture}
\end{center}
    ''' % (node_str, edge_str)





def graph(shape='circle',
          minimum_size='14mm',
          layout=None,
          xscale=1,
          yscale=2,
          edges='',
          separator=',',
          **args
          ):
    """ For output of graphs for latex using the pgf library """

    # get all the nodes from layout
    nodes = [x for x in layout.replace('\n', ' ').split(' ') if x != '']

    # now get nodes from args
    for key in args.keys():
        if key not in nodes: nodes.append(key)

    # put all nodes into dict and fill with default values
    node_dict = {}
    for node in nodes:
        node_dict[node] = {'shape':shape,
                           'minimum_size':minimum_size,
                           'pos':None,
                           'label':'$%s$' % node}

    # now overwrite with args
    for key,value in args.items():
        parts = [_.strip() for _ in value.split(separator) if _.strip() != '']
        for part in parts:
            try:
                k,v = part.split('=', 1)
                k,v = k.strip(), v.strip()
                node_dict[key][k] = v
            except:
                pass

    # remove pre and post blank lines
    layout_lines = [line for line in layout.split('\n')]
    
    # make sure every line has the same number of chars by appending ' '
    max_len = max([len(line) for line in layout_lines])
    layout_lines = [line + (max_len - len(line)) * ' ' for line in layout_lines]
    # remove leftmost char from every line if it's ' '
    while 1:
        # check if every line begins with ' '
        if all([line[0] == ' ' for line in layout_lines]):
            layout_lines = [line[1:] for line in layout_lines]
        else:
            break

    # now place the nodes
    s = ''
    for line_index, line in enumerate(layout_lines):
        for node in nodes:
            p = re.compile('(^| )%s(\Z| )' % node)
            search = p.search(line)
            if search:
                ind = search.start()
                if search.group()[0] == ' ': ind += 1
                shape = node_dict[node]['shape']

                if node_dict[node].has_key('graph coloring'):
                    label = node_dict[node]['label']
                    label = graph_coloring_label(eval(label))
                else:
                    label = node_dict[node]['label']

                size = 'minimum size=%s' % node_dict[node]['minimum_size']
                if shape=='rectangle':
                    if node_dict[node].has_key('minimum width'):
                        size += ',minimum width=%s' % node_dict[node]['minimum width']
                    if node_dict[node].has_key('minimum height'):
                        size += ',minimum height=%s' % node_dict[node]['minimum height']
                if node_dict[node].has_key('text width'):
                    size += ',text width=%s' % node_dict[node]['text width']
                s += r'\node at (%s,%s) [%s,draw,%s] (%s) {%s};' % \
                     (ind*xscale, -line_index*yscale, shape, size, node, label)
                s += '\n'

    #print "s:",
    
    # now add edges
    for edge in [_.strip() for _ in edges.strip().split(',') if _.strip() != '']:
        start = None
        for node in nodes:
            if edge.startswith(node):
                start = node
                break
        if start == None:
            print "\nERROR: UNKNOWN START NODE IN", edge, "\n"
            continue
        
        end = None
        for node in nodes:
            if edge.endswith(node):
                end = node
                break
        if end == None:
            print "\nERROR: UNKNOWN START NODE IN", edge, "\n"
            continue

        linetype = edge[len(start):][:-len(end)]
        
        if linetype == '>': linetype = '->'
        elif linetype == '<': linetype = '<-'
        elif linetype == '-': pass
        elif linetype == '->': pass
        elif linetype == 'dashed': linetype='dashed' #????
        else:
            print
            print "ERROR: UNKNOWN LINE TYPE", linetype
            print
            continue
        
        s += r'\draw [%s,thick] (%s) to (%s);' % (linetype, start, end)
        s += '\n'

    return r'''
\begin{tikzpicture}
%s
;
\end{tikzpicture}
    ''' % s
            
        

def test():

    print graph(layout='''

A B C
D E F

''',
                minimum_size='10mm',
                edges='A-B,A>D,E-C')




#==============================================================================
# Originally from plot.py
#==============================================================================
from math import *
import traceback

class Plot:
    def __init__(self,
                 width="5in",
                 height="3in",
                 domain="0:10",
                 color="black",
                 line_width='1',
                 num_points = 100,
                 vars=['x','y'] # independent and dependent vars
                 ):
        self.width = width
        self.height = height
        self.domain = domain
        self.color = color
        self.line_width = line_width
        self.num_points = num_points
        self.vars = vars
        if len(self.vars) == 1: self.vars.append('y')
        self.pre = r"""
\begin{center}
\begin{tikzpicture}[line width=%(line_width)s]
\begin{axis}[width=%(width)s, height=%(height)s]""" % {'height':self.height, 'width':self.width, 'line_width':line_width}
        self.body = ""
        self.post = r"""\end{axis}\end{tikzpicture}\end{center}"""
        self.exception = ''
        
    def add(self,
            *arglist,
            **argdict):
        """
        LINE GRAPH BY POINTS
        obj.add((1,1),(2,2),(3,3),line_width='1',color='black')

        LINE GRAPH BY LATEX FUNCTION
        obj.add("x**2 + 1",line_width='1',color='black')

        LINE GRAPH BY GENERATING POINTS BY PYTHON EXPRESSION
        obj.add("x**2 + 1", line_width='1', color='black', python=1)
        
        """
        try:
            d = {}
            d['color'] = argdict.get('color', self.color)
            d['line_width'] = argdict.get('line_width', self.line_width)
            d['domain'] = argdict.get('domain', self.domain)
            d['python'] = argdict.get('python', False)
            if d['python'] != False: d['python'] = True
            d['pin'] = argdict.get('pin', '')
            if d['pin'] in [1, '1', True]:
                d['pin'] = 'below right'
            d['style'] = argdict.get('style', '')
            d['num_points'] = argdict.get('num_points', self.num_points)
            if d['num_points'] <= 2: d['num_points'] = 3 # FIXIT
            d['vars'] = argdict.get('vars', self.vars)
            
            if isinstance(arglist[0], str):
                if not d['python']:
                    d['function'] = arglist[0]
                    d['expr'] = arglist[0]
                    partbody = r"""\addplot[draw=%(color)s, domain=%(domain)s, line width=%(line_width)s]{%(function)s};""" % d
                else: # python expr
                    d['expr'] = expr = arglist[0]
                    minx, maxx = d['domain'].split(':')
                    minx = float(minx.strip())
                    maxx = float(maxx.strip())
                    d['maxx'] = maxx
                    dx = (maxx - minx) / (d['num_points'] - 1)
                    x = minx; exec('%s = x' % d['vars'][0])
                    points = []
                    while x <= maxx:
                        try:
                            # in case for log function the x is not in domain
                            # can be a problem if the expression is written
                            # wrongly
                            #print "---> expr:", d['expr']
                            y = eval(d['expr'])
                            points.append("(%s,%s)" % (x,y))
                        except Exception, e1: # don't use e ... conflicts with math.e
                            pass
                            #print e
                        x += dx; exec('%s = x' % d['vars'][0])
                    
                    try:
                        # add last point just in case of fp errors
                        x = maxx; exec('%s = x' % d['vars'][0])
                        y = eval(d['expr'])
                        points.append("(%s,%s)" % (x,y))
                    except Exception, e1:
                        pass
                    
                    d['points'] = '\n'.join(points)
                            
            elif isinstance(arglist[0], (list, tuple)):
                d['points'] = "\n".join([str(_) for _ in arglist[0]]) 

            if d['style'] == '':
                partbody = r"""\addplot[draw=%(color)s, line width=%(line_width)s] coordinates {%(points)s};""" % d
                self.body += partbody
            elif d['style'] == 'step':
                partbody = r"""\addplot[const plot, draw=%(color)s, line width=%(line_width)s] coordinates {%(points)s};""" % d
                self.body += partbody

            # pin
            pin = ''
            if d['pin']:
                d['pin_message'] = "$y=%s$" % argdict.get('pin_message', d['expr'])
                d['pin_message'] = d['pin_message'].replace("**", "^") 
                d['pin_message'] = d['pin_message'].replace("*", " ")
                d['pin_message'] = d['pin_message'].replace("log(", "\log(")
                d['pin_message'] = d['pin_message'].replace("sin(", "\sin(")
                if d['pin_message'] == '$y=$': d['pin_message'] = ''
                d['pin_x'] = argdict.get('pin_x', d['maxx'] * 0.8) # depends on maxx
                x = d['pin_x']
                exec('%s = x' % d['vars'][0])
                if d['expr']:
                    d['pin_y'] = eval(expr) # depends on expr
                else:
                    d['pin_y'] = 0 # TODO

                if d['pin_message'] != '':
                    pin = r"""\node[pin=%(pin)s:{%(pin_message)s}] at (axis cs:%(pin_x)s,%(pin_y)s) {};""" % d
                
            self.body += pin
            
        except Exception, e:
            str_e = str(e)
            f = file('traceback.txt', 'w')
            traceback.print_exc(file=f)
            f.close()
            str_tb = file('traceback.txt', 'r').read()
            self.exception = '%s\n\n%s' % (str_tb, str_e)
    def __str__(self):
        if self.exception:
            return self.exception
        else:
            return "%s\n%s\n%s" % (self.pre, self.body, self.post)

if __name__ == '__main__': test()
